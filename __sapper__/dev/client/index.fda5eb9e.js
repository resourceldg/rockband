import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, G as ClassBuilder, v as validate_slots, F as assign, H as exclude_internal_props, e as element, t as text, k as space, c as claim_element, a as children, l as claim_text, b as detach_dev, m as claim_space, f as add_location, g as attr_dev, h as insert_dev, j as append_dev, a6 as set_input_value, W as action_destroyer, M as listen_dev, z as set_data_dev, N as prop_dev, n as noop, O as run_all, Q as bubble, aw as to_number } from './client.819ca0c7.js';
import { R as Ripple } from './index.6babd8b6.js';

/* src/components/Slider/Slider.svelte generated by Svelte v3.24.0 */
const file = "src/components/Slider/Slider.svelte";

function create_fragment(ctx) {
  let label_1;
  let t0;
  let t1;
  let input;
  let applyColor_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      label_1 = element("label");
      t0 = text(
      /*label*/
      ctx[1]);
      t1 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", {});
      var label_1_nodes = children(label_1);
      t0 = claim_text(label_1_nodes,
      /*label*/
      ctx[1]);
      label_1_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      input = claim_element(nodes, "INPUT", {
        type: true,
        class: true,
        min: true,
        max: true,
        step: true,
        disabled: true,
        style: true
      });
      this.h();
    },
    h: function hydrate() {
      add_location(label_1, file, 53, 0, 1244);
      attr_dev(input, "type", "range");
      attr_dev(input, "class",
      /*c*/
      ctx[7]);
      attr_dev(input, "min",
      /*min*/
      ctx[3]);
      attr_dev(input, "max",
      /*max*/
      ctx[4]);
      attr_dev(input, "step",
      /*step*/
      ctx[5]);
      input.disabled =
      /*disabled*/
      ctx[2];
      attr_dev(input, "style",
      /*style*/
      ctx[6]);
      add_location(input, file, 54, 0, 1267);
    },
    m: function mount(target, anchor) {
      insert_dev(target, label_1, anchor);
      append_dev(label_1, t0);
      insert_dev(target, t1, anchor);
      insert_dev(target, input, anchor);
      set_input_value(input,
      /*value*/
      ctx[0]);

      if (!mounted) {
        dispose = [action_destroyer(applyColor_action =
        /*applyColor*/
        ctx[8].call(null, input)), listen_dev(input, "change",
        /*input_change_input_handler*/
        ctx[12]), listen_dev(input, "input",
        /*input_change_input_handler*/
        ctx[12]), listen_dev(input, "change",
        /*change_handler*/
        ctx[11], false, false, false)];
        mounted = true;
      }
    },
    p: function update(ctx, [dirty]) {
      if (dirty &
      /*label*/
      2) set_data_dev(t0,
      /*label*/
      ctx[1]);

      if (dirty &
      /*c*/
      128) {
        attr_dev(input, "class",
        /*c*/
        ctx[7]);
      }

      if (dirty &
      /*min*/
      8) {
        attr_dev(input, "min",
        /*min*/
        ctx[3]);
      }

      if (dirty &
      /*max*/
      16) {
        attr_dev(input, "max",
        /*max*/
        ctx[4]);
      }

      if (dirty &
      /*step*/
      32) {
        attr_dev(input, "step",
        /*step*/
        ctx[5]);
      }

      if (dirty &
      /*disabled*/
      4) {
        prop_dev(input, "disabled",
        /*disabled*/
        ctx[2]);
      }

      if (dirty &
      /*style*/
      64) {
        attr_dev(input, "style",
        /*style*/
        ctx[6]);
      }

      if (dirty &
      /*value*/
      1) {
        set_input_value(input,
        /*value*/
        ctx[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(label_1);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    value = 0
  } = $$props;
  let {
    label = ""
  } = $$props;
  let {
    color = "primary"
  } = $$props;
  let {
    disabled = false
  } = $$props;
  let {
    min = 0
  } = $$props;
  let {
    max = 100
  } = $$props;
  let {
    step = null
  } = $$props;
  const classesDefault = `bg-${color}-50 w-full rounded cursor-pointer`;
  let {
    classes = classesDefault
  } = $$props;
  let toPercent;
  const cb = new ClassBuilder(classes, classesDefault);

  const getColor = c => `var(${c})`;

  let style;

  function applyColor(node) {
    if (typeof window === "undefined") return false;
    let c = getColor(`--color-${color}-500`);
    node.style.setProperty("--bg", c);
    node.style.setProperty("--bg-focus", c);
  }

  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Slider", $$slots, []);

  function change_handler(event) {
    bubble($$self, event);
  }

  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }

  $$self.$set = $$new_props => {
    $$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    if ("color" in $$new_props) $$invalidate(9, color = $$new_props.color);
    if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("min" in $$new_props) $$invalidate(3, min = $$new_props.min);
    if ("max" in $$new_props) $$invalidate(4, max = $$new_props.max);
    if ("step" in $$new_props) $$invalidate(5, step = $$new_props.step);
    if ("classes" in $$new_props) $$invalidate(10, classes = $$new_props.classes);
  };

  $$self.$capture_state = () => ({
    ClassBuilder,
    Ripple,
    value,
    label,
    color,
    disabled,
    min,
    max,
    step,
    classesDefault,
    classes,
    toPercent,
    cb,
    getColor,
    style,
    applyColor,
    c
  });

  $$self.$inject_state = $$new_props => {
    $$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    if ("color" in $$props) $$invalidate(9, color = $$new_props.color);
    if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    if ("min" in $$props) $$invalidate(3, min = $$new_props.min);
    if ("max" in $$props) $$invalidate(4, max = $$new_props.max);
    if ("step" in $$props) $$invalidate(5, step = $$new_props.step);
    if ("classes" in $$props) $$invalidate(10, classes = $$new_props.classes);
    if ("toPercent" in $$props) $$invalidate(13, toPercent = $$new_props.toPercent);
    if ("style" in $$props) $$invalidate(6, style = $$new_props.style);
    if ("c" in $$props) $$invalidate(7, c = $$new_props.c);
  };

  let c;

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*max, min*/
    24) {
       {
        let factor = 100 / (max - min);
        $$invalidate(13, toPercent = v => (v - min) * factor);
      }
    }

     $$invalidate(7, c = cb.flush().add(classes, true, classesDefault).add($$props.class).get());

    if ($$self.$$.dirty &
    /*color, toPercent, value, disabled*/
    8709) {
       {
        let c1 = getColor(`--color-${color}-500`);
        let c2 = getColor(`--color-${color}-200`);
        let cv = toPercent(value);
        $$invalidate(6, style = disabled ? "" : `background: linear-gradient(to right, ${c1} 0%, ${c1} ${cv}%, ${c2} ${cv}%, ${c2} 100%); --bg: ${c1}; --bg-focus: ${c1}`);
      }
    }
  };

  $$props = exclude_internal_props($$props);
  return [value, label, disabled, min, max, step, style, c, applyColor, color, classes, change_handler, input_change_input_handler];
}

class Slider extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      value: 0,
      label: 1,
      color: 9,
      disabled: 2,
      min: 3,
      max: 4,
      step: 5,
      classes: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment.name
    });
  }

  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get label() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set label(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get color() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set color(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get classes() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set classes(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export { Slider as S };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZmRhNWViOWUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1NsaWRlci9TbGlkZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IENsYXNzQnVpbGRlciB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzc2VzLmpzXCI7XG5cbiAgaW1wb3J0IFJpcHBsZSBmcm9tIFwiLi4vUmlwcGxlXCI7XG5cbiAgZXhwb3J0IGxldCB2YWx1ZSA9IDA7XG4gIGV4cG9ydCBsZXQgbGFiZWwgPSBcIlwiO1xuICBleHBvcnQgbGV0IGNvbG9yID0gXCJwcmltYXJ5XCI7XG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBtaW4gPSAwO1xuICBleHBvcnQgbGV0IG1heCA9IDEwMDtcbiAgZXhwb3J0IGxldCBzdGVwID0gbnVsbDtcblxuICBjb25zdCBjbGFzc2VzRGVmYXVsdCA9IGBiZy0ke2NvbG9yfS01MCB3LWZ1bGwgcm91bmRlZCBjdXJzb3ItcG9pbnRlcmA7XG5cbiAgZXhwb3J0IGxldCBjbGFzc2VzID0gY2xhc3Nlc0RlZmF1bHQ7XG5cbiAgbGV0IHRvUGVyY2VudDtcbiAgJDoge1xuICAgIGxldCBmYWN0b3IgPSAxMDAuMCAvIChtYXggLSBtaW4pO1xuICAgIHRvUGVyY2VudCA9IHYgPT4gKHYgLSBtaW4pICogZmFjdG9yO1xuICB9XG5cbiAgY29uc3QgY2IgPSBuZXcgQ2xhc3NCdWlsZGVyKGNsYXNzZXMsIGNsYXNzZXNEZWZhdWx0KTtcblxuICAkOiBjID0gY2JcbiAgICAuZmx1c2goKVxuICAgIC5hZGQoY2xhc3NlcywgdHJ1ZSwgY2xhc3Nlc0RlZmF1bHQpXG4gICAgLmFkZCgkJHByb3BzLmNsYXNzKVxuICAgIC5nZXQoKTtcblxuICBjb25zdCBnZXRDb2xvciA9IGMgPT4gYHZhcigke2N9KWBcblxuICBsZXQgc3R5bGU7XG4gICQ6IHtcbiAgICBsZXQgYzEgPSBnZXRDb2xvcihgLS1jb2xvci0ke2NvbG9yfS01MDBgKTtcbiAgICBsZXQgYzIgPSBnZXRDb2xvcihgLS1jb2xvci0ke2NvbG9yfS0yMDBgKTtcbiAgICBsZXQgY3YgPSB0b1BlcmNlbnQodmFsdWUpO1xuICAgIHN0eWxlID0gZGlzYWJsZWRcbiAgICA/IFwiXCJcbiAgICA6IGBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICR7YzF9IDAlLCAke2MxfSAke2N2fSUsICR7YzJ9ICR7Y3Z9JSwgJHtjMn0gMTAwJSk7IC0tYmc6ICR7YzF9OyAtLWJnLWZvY3VzOiAke2MxfWA7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUNvbG9yKG5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IGMgPSBnZXRDb2xvcihgLS1jb2xvci0ke2NvbG9yfS01MDBgKTtcbiAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KCctLWJnJywgYyk7XG4gICAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1iZy1mb2N1cycsIGMpO1xuICB9XG5cbjwvc2NyaXB0PlxuXG48bGFiZWw+e2xhYmVsfTwvbGFiZWw+XG48aW5wdXRcbiAgdXNlOmFwcGx5Q29sb3JcbiAgdHlwZT1cInJhbmdlXCJcbiAgY2xhc3M9e2N9XG4gIHttaW59XG4gIHttYXh9XG4gIHtzdGVwfVxuICB7ZGlzYWJsZWR9XG4gIGJpbmQ6dmFsdWVcbiAgb246Y2hhbmdlXG4gIHN0eWxlPXtzdHlsZX1cbj5cbiJdLCJuYW1lcyI6WyJjdHgiLCJ2YWx1ZSIsImxhYmVsIiwiY29sb3IiLCJkaXNhYmxlZCIsIm1pbiIsIm1heCIsInN0ZXAiLCJjbGFzc2VzRGVmYXVsdCIsImNsYXNzZXMiLCJ0b1BlcmNlbnQiLCJjYiIsIkNsYXNzQnVpbGRlciIsImdldENvbG9yIiwiYyIsInN0eWxlIiwiYXBwbHlDb2xvciIsIm5vZGUiLCJ3aW5kb3ciLCJzZXRQcm9wZXJ0eSIsIiQiLCJmYWN0b3IiLCJ2IiwiZmx1c2giLCJhZGQiLCIkJHByb3BzIiwiY2xhc3MiLCJnZXQiLCJjMSIsImMyIiwiY3YiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxRFFBLE1BQUFBLEdBQUssRUFBQTs7Ozs7Ozs7OztBQUFMQSxNQUFBQSxHQUFLLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJSkEsTUFBQUEsR0FBQyxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFPREEsTUFBQUEsR0FBSyxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFYTkEsTUFBQUEsR0FBSyxFQUFBOzs7Ozs7O0FBSUpBLFFBQUFBLEdBQUMsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9EQSxRQUFBQSxHQUFLLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTNEREMsSUFBQUEsS0FBSyxHQUFHOzs7QUFDUkMsSUFBQUEsS0FBSyxHQUFHOzs7QUFDUkMsSUFBQUEsS0FBSyxHQUFHOzs7QUFDUkMsSUFBQUEsUUFBUSxHQUFHOzs7QUFDWEMsSUFBQUEsR0FBRyxHQUFHOzs7QUFDTkMsSUFBQUEsR0FBRyxHQUFHOzs7QUFDTkMsSUFBQUEsSUFBSSxHQUFHOztRQUVaQyxjQUFjLFNBQVNMOztBQUVsQk0sSUFBQUEsT0FBTyxHQUFHRDs7TUFFakJFO1FBTUVDLEVBQUUsT0FBT0MsYUFBYUgsU0FBU0Q7O1FBUS9CSyxRQUFRLEdBQUdDLENBQUMsV0FBV0E7O01BRXpCQzs7V0FVS0MsV0FBV0M7ZUFDUEMsV0FBVyxvQkFBb0I7UUFFdENKLENBQUMsR0FBR0QsUUFBUSxZQUFZVixXQUFaO0FBQ2hCYyxJQUFBQSxJQUFJLENBQUNGLEtBQUwsQ0FBV0ksV0FBWCxDQUF1QixNQUF2QixFQUErQkwsQ0FBL0I7QUFDQUcsSUFBQUEsSUFBSSxDQUFDRixLQUFMLENBQVdJLFdBQVgsQ0FBdUIsWUFBdkIsRUFBcUNMLENBQXJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE5QkZNO1lBQ01DLE1BQU0sR0FBRyxPQUFTZixHQUFHLEdBQUdELEdBQWY7eUJBQ2JLLFNBQVMsR0FBR1ksQ0FBQyxLQUFLQSxDQUFDLEdBQUdqQixPQUFPZ0I7Ozs7QUFLL0JELHFCQUFHTixDQUFDLEdBQUdILEVBQUUsQ0FDTlksS0FESSxHQUVKQyxHQUZJLENBRUFmLE9BRkEsRUFFUyxJQUZULEVBRWVELGNBRmYsRUFHSmdCLEdBSEksQ0FHQUMsT0FBTyxDQUFDQyxLQUhSLEVBSUpDLEdBSkk7Ozs7O0FBU1BQO1lBQ01RLEVBQUUsR0FBR2YsUUFBUSxZQUFZVixXQUFaO1lBQ2IwQixFQUFFLEdBQUdoQixRQUFRLFlBQVlWLFdBQVo7WUFDYjJCLEVBQUUsR0FBR3BCLFNBQVMsQ0FBQ1QsS0FBRDt3QkFDbEJjLEtBQUssR0FBR1gsUUFBUSxHQUNkLEVBRGMsNENBRTJCd0IsVUFBVUEsTUFBTUUsUUFBUUQsTUFBTUMsUUFBUUQsbUJBQW1CRCxtQkFBbUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
