import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, x as create_slot, y as showNav, v as validate_slots, e as element, t as text, c as claim_element, a as children, l as claim_text, b as detach_dev, g as attr_dev, f as add_location, h as insert_dev, j as append_dev, z as set_data_dev, k as space, A as query_selector_all, m as claim_space, B as update_slot, r as transition_in, u as transition_out } from './client.29f7f57a.js';

/* src/routes/components/_layout.svelte generated by Svelte v3.24.0 */
const file = "src/routes/components/_layout.svelte"; // (18:0) {#if segment}

function create_if_block(ctx) {
  let h4;
  let t;
  const block = {
    c: function create() {
      h4 = element("h4");
      t = text(
      /*name*/
      ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      h4 = claim_element(nodes, "H4", {
        class: true
      });
      var h4_nodes = children(h4);
      t = claim_text(h4_nodes,
      /*name*/
      ctx[1]);
      h4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h4, "class", "capitalize pb-8");
      add_location(h4, file, 18, 2, 414);
    },
    m: function mount(target, anchor) {
      insert_dev(target, h4, anchor);
      append_dev(h4, t);
    },
    p: function update(ctx, dirty) {
      if (dirty &
      /*name*/
      2) set_data_dev(t,
      /*name*/
      ctx[1]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(h4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(18:0) {#if segment}",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let title_value;
  let meta;
  let meta_content_value;
  let t0;
  let t1;
  let current;
  document.title = title_value = "\n    " + (
  /*name*/
  ctx[1] ? `${
  /*name*/
  ctx[1]} |` : "") + " Waladocs.\n  ";
  let if_block =
  /*segment*/
  ctx[0] && create_if_block(ctx);
  const default_slot_template =
  /*$$slots*/
  ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[2], null);
  const block = {
    c: function create() {
      meta = element("meta");
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = query_selector_all("[data-svelte=\"svelte-1wi97xh\"]", document.head);
      meta = claim_element(head_nodes, "META", {
        name: true,
        content: true
      });
      head_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot) default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "description");
      attr_dev(meta, "content", meta_content_value = "Walatic documentation. " +
      /*name*/
      ctx[1]);
      add_location(meta, file, 14, 3, 316);
    },
    m: function mount(target, anchor) {
      append_dev(document.head, meta);
      insert_dev(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, t1, anchor);

      if (default_slot) {
        default_slot.m(target, anchor);
      }

      current = true;
    },
    p: function update(ctx, [dirty]) {
      if ((!current || dirty &
      /*name*/
      2) && title_value !== (title_value = "\n    " + (
      /*name*/
      ctx[1] ? `${
      /*name*/
      ctx[1]} |` : "") + " Waladocs.\n  ")) {
        document.title = title_value;
      }

      if (!current || dirty &
      /*name*/
      2 && meta_content_value !== (meta_content_value = "Walatic documentation. " +
      /*name*/
      ctx[1])) {
        attr_dev(meta, "content", meta_content_value);
      }

      if (
      /*segment*/
      ctx[0]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }

      if (default_slot) {
        if (default_slot.p && dirty &
        /*$$scope*/
        4) {
          update_slot(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[2], dirty, null, null);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      detach_dev(meta);
      if (detaching) detach_dev(t0);
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(t1);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    segment = ""
  } = $$props;
  showNav.set(true);
  const writable_props = ["segment"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Layout", $$slots, ['default']);

  $$self.$set = $$props => {
    if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
    if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
  };

  $$self.$capture_state = () => ({
    showNav,
    segment,
    n,
    name
  });

  $$self.$inject_state = $$props => {
    if ("segment" in $$props) $$invalidate(0, segment = $$props.segment);
    if ("n" in $$props) $$invalidate(4, n = $$props.n);
    if ("name" in $$props) $$invalidate(1, name = $$props.name);
  };

  let n;
  let name;

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*segment*/
    1) {
       $$invalidate(4, n = (segment || "").replace(new RegExp("-", "g"), " "));
    }

    if ($$self.$$.dirty &
    /*n*/
    16) {
       $$invalidate(1, name = n.length ? n.charAt(0).toUpperCase() + n.slice(1) : "");
    }
  };

  return [segment, name, $$scope, $$slots];
}

class Layout extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      segment: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layout",
      options,
      id: create_fragment.name
    });
  }

  get segment() {
    throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set segment(value) {
    throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default Layout;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2xheW91dC4yYTQ3OGNlYi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9jb21wb25lbnRzL19sYXlvdXQuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHNob3dOYXYgfSBmcm9tIFwic3RvcmVzLmpzXCI7XG4gIGV4cG9ydCBsZXQgc2VnbWVudCA9IFwiXCI7XG5cbiAgc2hvd05hdi5zZXQodHJ1ZSk7XG4gICQ6IG4gPSAoc2VnbWVudCB8fCBcIlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoJy0nLCAnZycpLCAnICcpO1xuICAkOiBuYW1lID0gbi5sZW5ndGggPyBuLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbi5zbGljZSgxKSA6IFwiXCI7XG5cbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT5cbiAgICB7bmFtZSA/IGAke25hbWV9IHxgIDogXCJcIn0gV2FsYWRvY3MuXG4gIDwvdGl0bGU+XG4gICA8bWV0YSBuYW1lPVwiZGVzY3JpcHRpb25cIiBjb250ZW50PVwiV2FsYXRpYyBkb2N1bWVudGF0aW9uLiB7bmFtZX1cIj5cbjwvc3ZlbHRlOmhlYWQ+XG5cbnsjaWYgc2VnbWVudH1cbiAgPGg0IGNsYXNzPVwiY2FwaXRhbGl6ZSBwYi04XCI+e25hbWV9PC9oND5cbnsvaWZ9XG48c2xvdCAvPiJdLCJuYW1lcyI6WyJjdHgiLCJzZWdtZW50Iiwic2hvd05hdiIsInNldCIsIiQiLCJuIiwicmVwbGFjZSIsIlJlZ0V4cCIsIm5hbWUiLCJsZW5ndGgiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBa0IrQkEsTUFBQUEsR0FBSSxFQUFBOzs7Ozs7Ozs7O0FBQUpBLE1BQUFBLEdBQUksRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBSkEsTUFBQUEsR0FBSSxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTjlCQSxFQUFBQSxHQUFJLEVBQUEsQ0FBSjs7QUFBVUEsRUFBQUEsR0FBSSxFQUFBLEtBQWQsR0FBcUI7OztBQUtyQkEsRUFBQUEsR0FBTyxFQUFBLENBQVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUh3REEsTUFBQUEsR0FBSSxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUY1REEsTUFBQUEsR0FBSSxFQUFBLENBQUo7O0FBQVVBLE1BQUFBLEdBQUksRUFBQSxLQUFkLEdBQXFCOzs7Ozs7OztBQUVtQ0EsTUFBQUEsR0FBSSxFQUFBOzs7Ozs7QUFHNURBLE1BQUFBLEdBQU8sRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWZDQyxJQUFBQSxPQUFPLEdBQUc7O0FBRXJCQyxFQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSxJQUFaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0FDLHVCQUFHQyxDQUFDLElBQUlKLE9BQU8sSUFBSSxJQUFJSyxZQUFZQyxPQUFPLEtBQUssTUFBTTs7Ozs7O0FBQ3JESCx1QkFBR0ksSUFBSSxHQUFHSCxDQUFDLENBQUNJLE1BQUYsR0FBV0osQ0FBQyxDQUFDSyxNQUFGLENBQVMsQ0FBVCxFQUFZQyxXQUFaLEtBQTRCTixDQUFDLENBQUNPLEtBQUYsQ0FBUSxDQUFSLENBQXZDLEdBQW9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
