import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, x as create_slot, G as ClassBuilder, K as createEventDispatcher, v as validate_slots, F as assign, H as exclude_internal_props, aa as fly, ab as quadOut, aj as quadIn, am as List, R as empty, h as insert_dev, r as transition_in, T as group_outros, u as transition_out, U as check_outros, b as detach_dev, e as element, k as space, c as claim_element, a as children, m as claim_space, g as attr_dev, f as add_location, j as append_dev, M as listen_dev, an as stop_propagation, B as update_slot, O as run_all, Q as bubble, a0 as binding_callbacks, a1 as bind, o as create_component, p as claim_component, q as mount_component, J as get_spread_update, a5 as get_spread_object, a2 as add_flush_callback, ac as add_render_callback, ao as create_in_transition, ap as create_out_transition, w as destroy_component } from './client.7a6793f2.js';
import { T as TextField } from './index.762ff2ef.js';

/* src/components/Menu/Menu.svelte generated by Svelte v3.24.0 */
const file = "src/components/Menu/Menu.svelte";

const get_menu_slot_changes = dirty => ({});

const get_menu_slot_context = ctx => ({});

const get_activator_slot_changes = dirty => ({});

const get_activator_slot_context = ctx => ({}); // (47:4) {#if open}


function create_if_block(ctx) {
  let div;
  let list;
  let updating_value;
  let div_intro;
  let div_outro;
  let current;
  const list_spread_levels = [{
    select: true
  }, {
    dense: true
  }, {
    items:
    /*items*/
    ctx[2]
  },
  /*listProps*/
  ctx[3]];

  function list_value_binding(value) {
    /*list_value_binding*/
    ctx[14].call(null, value);
  }

  let list_props = {};

  for (let i = 0; i < list_spread_levels.length; i += 1) {
    list_props = assign(list_props, list_spread_levels[i]);
  }

  if (
  /*value*/
  ctx[1] !== void 0) {
    list_props.value =
    /*value*/
    ctx[1];
  }

  list = new List({
    props: list_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(list, "value", list_value_binding));
  list.$on("change",
  /*change_handler*/
  ctx[15]);
  list.$on("change",
  /*change_handler_1*/
  ctx[16]);
  const block = {
    c: function create() {
      div = element("div");
      create_component(list.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      claim_component(list.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class",
      /*l*/
      ctx[5]);
      add_location(div, file, 47, 6, 1265);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(list, div, null);
      current = true;
    },
    p: function update(ctx, dirty) {
      const list_changes = dirty &
      /*items, listProps*/
      12 ? get_spread_update(list_spread_levels, [list_spread_levels[0], list_spread_levels[1], dirty &
      /*items*/
      4 && {
        items:
        /*items*/
        ctx[2]
      }, dirty &
      /*listProps*/
      8 && get_spread_object(
      /*listProps*/
      ctx[3])]) : {};

      if (!updating_value && dirty &
      /*value*/
      2) {
        updating_value = true;
        list_changes.value =
        /*value*/
        ctx[1];
        add_flush_callback(() => updating_value = false);
      }

      list.$set(list_changes);

      if (!current || dirty &
      /*l*/
      32) {
        attr_dev(div, "class",
        /*l*/
        ctx[5]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(list.$$.fragment, local);
      add_render_callback(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = create_in_transition(div, fly,
        /*inProps*/
        ctx[6]);
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(list.$$.fragment, local);
      if (div_intro) div_intro.invalidate();
      div_outro = create_out_transition(div, fly,
      /*outProps*/
      ctx[7]);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      destroy_component(list);
      if (detaching && div_outro) div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(47:4) {#if open}",
    ctx
  });
  return block;
} // (46:20)      


function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block =
  /*open*/
  ctx[0] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (
      /*open*/
      ctx[0]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(46:20)      ",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let div;
  let t;
  let current;
  let mounted;
  let dispose;
  const activator_slot_template =
  /*$$slots*/
  ctx[11].activator;
  const activator_slot = create_slot(activator_slot_template, ctx,
  /*$$scope*/
  ctx[10], get_activator_slot_context);
  const menu_slot_template =
  /*$$slots*/
  ctx[11].menu;
  const menu_slot = create_slot(menu_slot_template, ctx,
  /*$$scope*/
  ctx[10], get_menu_slot_context);
  const menu_slot_or_fallback = menu_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (activator_slot) activator_slot.c();
      t = space();
      if (menu_slot_or_fallback) menu_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      if (activator_slot) activator_slot.l(div_nodes);
      t = claim_space(div_nodes);
      if (menu_slot_or_fallback) menu_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class",
      /*c*/
      ctx[4]);
      add_location(div, file, 43, 0, 1154);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);

      if (activator_slot) {
        activator_slot.m(div, null);
      }

      append_dev(div, t);

      if (menu_slot_or_fallback) {
        menu_slot_or_fallback.m(div, null);
      }

      current = true;

      if (!mounted) {
        dispose = [listen_dev(window, "click",
        /*click_handler_1*/
        ctx[13], false, false, false), listen_dev(div, "click", stop_propagation(
        /*click_handler*/
        ctx[12]), false, false, true)];
        mounted = true;
      }
    },
    p: function update(ctx, [dirty]) {
      if (activator_slot) {
        if (activator_slot.p && dirty &
        /*$$scope*/
        1024) {
          update_slot(activator_slot, activator_slot_template, ctx,
          /*$$scope*/
          ctx[10], dirty, get_activator_slot_changes, get_activator_slot_context);
        }
      }

      if (menu_slot) {
        if (menu_slot.p && dirty &
        /*$$scope*/
        1024) {
          update_slot(menu_slot, menu_slot_template, ctx,
          /*$$scope*/
          ctx[10], dirty, get_menu_slot_changes, get_menu_slot_context);
        }
      } else {
        if (menu_slot_or_fallback && menu_slot_or_fallback.p && dirty &
        /*l, items, listProps, value, open*/
        47) {
          menu_slot_or_fallback.p(ctx, dirty);
        }
      }

      if (!current || dirty &
      /*c*/
      16) {
        attr_dev(div, "class",
        /*c*/
        ctx[4]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(activator_slot, local);
      transition_in(menu_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(activator_slot, local);
      transition_out(menu_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      if (activator_slot) activator_slot.d(detaching);
      if (menu_slot_or_fallback) menu_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

const classesDefault = "cursor-pointer relative";
const listClassesDefault = "absolute w-auto top-16 bg-white left-0 bg-white rounded elevation-3 z-20 dark:bg-dark-500";

function instance($$self, $$props, $$invalidate) {
  let {
    items = []
  } = $$props;
  let {
    open = false
  } = $$props;
  let {
    value = null
  } = $$props;
  let {
    classes = classesDefault
  } = $$props;
  let {
    listClasses = listClassesDefault
  } = $$props;
  let {
    listProps = {}
  } = $$props;
  const cb = new ClassBuilder($$props.class);
  const lcb = new ClassBuilder(listClasses, listClassesDefault);
  const dispatch = createEventDispatcher();
  const inProps = {
    y: 10,
    duration: 200,
    easing: quadIn
  };
  const outProps = {
    y: -10,
    duration: 100,
    easing: quadOut,
    delay: 100
  };
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Menu", $$slots, ['activator', 'menu']);

  function click_handler(event) {
    bubble($$self, event);
  }

  const click_handler_1 = () => $$invalidate(0, open = false);

  function list_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }

  function change_handler(event) {
    bubble($$self, event);
  }

  const change_handler_1 = () => $$invalidate(0, open = false);

  $$self.$set = $$new_props => {
    $$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("items" in $$new_props) $$invalidate(2, items = $$new_props.items);
    if ("open" in $$new_props) $$invalidate(0, open = $$new_props.open);
    if ("value" in $$new_props) $$invalidate(1, value = $$new_props.value);
    if ("classes" in $$new_props) $$invalidate(8, classes = $$new_props.classes);
    if ("listClasses" in $$new_props) $$invalidate(9, listClasses = $$new_props.listClasses);
    if ("listProps" in $$new_props) $$invalidate(3, listProps = $$new_props.listProps);
    if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
  };

  $$self.$capture_state = () => ({
    createEventDispatcher,
    fly,
    quadOut,
    quadIn,
    List,
    TextField,
    ClassBuilder,
    classesDefault,
    listClassesDefault,
    items,
    open,
    value,
    classes,
    listClasses,
    listProps,
    cb,
    lcb,
    dispatch,
    inProps,
    outProps,
    c,
    l
  });

  $$self.$inject_state = $$new_props => {
    $$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
    if ("items" in $$props) $$invalidate(2, items = $$new_props.items);
    if ("open" in $$props) $$invalidate(0, open = $$new_props.open);
    if ("value" in $$props) $$invalidate(1, value = $$new_props.value);
    if ("classes" in $$props) $$invalidate(8, classes = $$new_props.classes);
    if ("listClasses" in $$props) $$invalidate(9, listClasses = $$new_props.listClasses);
    if ("listProps" in $$props) $$invalidate(3, listProps = $$new_props.listProps);
    if ("c" in $$props) $$invalidate(4, c = $$new_props.c);
    if ("l" in $$props) $$invalidate(5, l = $$new_props.l);
  };

  let c;
  let l;

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
     $$invalidate(4, c = cb.flush().add(classes, true, classesDefault).add($$props.class).get());
  };

   $$invalidate(5, l = lcb.flush().get());

  $$props = exclude_internal_props($$props);
  return [open, value, items, listProps, c, l, inProps, outProps, classes, listClasses, $$scope, $$slots, click_handler, click_handler_1, list_value_binding, change_handler, change_handler_1];
}

class Menu extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      items: 2,
      open: 0,
      value: 1,
      classes: 8,
      listClasses: 9,
      listProps: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment.name
    });
  }

  get items() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set items(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get open() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set open(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get value() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set value(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get classes() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set classes(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get listClasses() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set listClasses(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get listProps() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set listProps(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export { Menu as M };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNDBmYjZiNzAuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL01lbnUvTWVudS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBmbHkgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgaW1wb3J0IHsgcXVhZE91dCwgcXVhZEluIH0gZnJvbSBcInN2ZWx0ZS9lYXNpbmdcIjtcbiAgaW1wb3J0IExpc3QgZnJvbSBcIi4uL0xpc3RcIjtcbiAgaW1wb3J0IFRleHRGaWVsZCBmcm9tIFwiLi4vVGV4dEZpZWxkXCI7XG4gIGltcG9ydCB7IENsYXNzQnVpbGRlciB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzc2VzLmpzXCI7XG5cbiAgY29uc3QgY2xhc3Nlc0RlZmF1bHQgPSBcImN1cnNvci1wb2ludGVyIHJlbGF0aXZlXCI7XG4gIGNvbnN0IGxpc3RDbGFzc2VzRGVmYXVsdCA9IFwiYWJzb2x1dGUgdy1hdXRvIHRvcC0xNiBiZy13aGl0ZSBsZWZ0LTAgYmctd2hpdGUgcm91bmRlZCBlbGV2YXRpb24tMyB6LTIwIGRhcms6YmctZGFyay01MDBcIjtcblxuICBleHBvcnQgbGV0IGl0ZW1zID0gW107XG4gIGV4cG9ydCBsZXQgb3BlbiA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHZhbHVlID0gbnVsbDtcbiAgZXhwb3J0IGxldCBjbGFzc2VzID0gY2xhc3Nlc0RlZmF1bHQ7XG4gIGV4cG9ydCBsZXQgbGlzdENsYXNzZXMgPSBsaXN0Q2xhc3Nlc0RlZmF1bHQ7XG4gIGV4cG9ydCBsZXQgbGlzdFByb3BzID0ge307XG5cblxuXG5cbiAgY29uc3QgY2IgPSBuZXcgQ2xhc3NCdWlsZGVyKCQkcHJvcHMuY2xhc3MpO1xuXG4gICQ6IGMgPSBjYlxuICAgIC5mbHVzaCgpXG4gICAgLmFkZChjbGFzc2VzLCB0cnVlLCBjbGFzc2VzRGVmYXVsdClcbiAgICAuYWRkKCQkcHJvcHMuY2xhc3MpXG4gICAgLmdldCgpO1xuXG4gIGNvbnN0IGxjYiA9IG5ldyBDbGFzc0J1aWxkZXIobGlzdENsYXNzZXMsIGxpc3RDbGFzc2VzRGVmYXVsdCk7XG5cbiAgJDogbCA9IGxjYlxuICAgICAgLmZsdXNoKClcbiAgICAgIC5nZXQoKTtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGNvbnN0IGluUHJvcHMgPSB7IHk6IDEwLCBkdXJhdGlvbjogMjAwLCBlYXNpbmc6IHF1YWRJbiB9O1xuICBjb25zdCBvdXRQcm9wcyA9IHsgeTogLTEwLCBkdXJhdGlvbjogMTAwLCBlYXNpbmc6IHF1YWRPdXQsIGRlbGF5OiAxMDAgfTtcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOndpbmRvdyBvbjpjbGljaz17KCkgPT4gKG9wZW4gPSBmYWxzZSl9IC8+XG5cbjxkaXYgY2xhc3M9e2N9IG9uOmNsaWNrfHN0b3BQcm9wYWdhdGlvbj5cbiAgPHNsb3QgbmFtZT1cImFjdGl2YXRvclwiIC8+XG4gIDxzbG90IG5hbWU9XCJtZW51XCI+XG4gICAgeyNpZiBvcGVufVxuICAgICAgPGRpdiBjbGFzcz17bH0gaW46Zmx5PXtpblByb3BzfSBvdXQ6Zmx5PXtvdXRQcm9wc30+XG4gICAgICAgIDxMaXN0XG4gICAgICAgICAgYmluZDp2YWx1ZVxuICAgICAgICAgIHNlbGVjdFxuICAgICAgICAgIGRlbnNlXG4gICAgICAgICAge2l0ZW1zfVxuICAgICAgICAgIG9uOmNoYW5nZVxuICAgICAgICAgIG9uOmNoYW5nZT17KCkgPT4gb3BlbiA9IGZhbHNlfVxuICAgICAgICAgIHsuLi5saXN0UHJvcHN9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICB7L2lmfVxuICA8L3Nsb3Q+XG48L2Rpdj5cbiJdLCJuYW1lcyI6WyJjdHgiLCJjbGFzc2VzRGVmYXVsdCIsImxpc3RDbGFzc2VzRGVmYXVsdCIsIml0ZW1zIiwib3BlbiIsInZhbHVlIiwiY2xhc3NlcyIsImxpc3RDbGFzc2VzIiwibGlzdFByb3BzIiwiY2IiLCJDbGFzc0J1aWxkZXIiLCIkJHByb3BzIiwiY2xhc3MiLCJsY2IiLCJkaXNwYXRjaCIsImNyZWF0ZUV2ZW50RGlzcGF0Y2hlciIsImluUHJvcHMiLCJ5IiwiZHVyYXRpb24iLCJlYXNpbmciLCJxdWFkSW4iLCJvdXRQcm9wcyIsInF1YWRPdXQiLCJkZWxheSIsIiQiLCJjIiwiZmx1c2giLCJhZGQiLCJnZXQiLCJsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVEY0EsRUFBQUEsR0FBUyxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVJMQSxNQUFBQSxHQUFDLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFMQSxNQUFBQSxHQUFTLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFSTEEsUUFBQUEsR0FBQyxFQUFBOzs7Ozs7Ozs7O0FBQVVBLFFBQUFBLEdBQU8sRUFBQTs7Ozs7Ozs7OztBQUFXQSxNQUFBQSxHQUFRLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEOUNBLEVBQUFBLEdBQUksRUFBQSxDQUFKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQUEsTUFBQUEsR0FBSSxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSERBLE1BQUFBLEdBQUMsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBREEsUUFBQUEsR0FBQyxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQW5DTEMsY0FBYyxHQUFHO01BQ2pCQyxrQkFBa0IsR0FBRzs7OztBQUVoQkMsSUFBQUEsS0FBSzs7O0FBQ0xDLElBQUFBLElBQUksR0FBRzs7O0FBQ1BDLElBQUFBLEtBQUssR0FBRzs7O0FBQ1JDLElBQUFBLE9BQU8sR0FBR0w7OztBQUNWTSxJQUFBQSxXQUFXLEdBQUdMOzs7QUFDZE0sSUFBQUEsU0FBUzs7UUFLZEMsRUFBRSxPQUFPQyxhQUFhQyxPQUFPLENBQUNDO1FBUTlCQyxHQUFHLE9BQU9ILGFBQWFILGFBQWFMO1FBTXBDWSxRQUFRLEdBQUdDLHFCQUFxQjtRQUVoQ0MsT0FBTztBQUFLQyxJQUFBQSxDQUFDLEVBQUU7QUFBSUMsSUFBQUEsUUFBUSxFQUFFO0FBQUtDLElBQUFBLE1BQU0sRUFBRUM7O1FBQzFDQyxRQUFRO0FBQUtKLElBQUFBLENBQUMsR0FBRztBQUFJQyxJQUFBQSxRQUFRLEVBQUU7QUFBS0MsSUFBQUEsTUFBTSxFQUFFRztBQUFTQyxJQUFBQSxLQUFLLEVBQUU7Ozs7Ozs7Ozs7OztnREFHcENuQixJQUFJLEdBQUc7Ozs7Ozs7Ozs7O2lEQWFaQSxJQUFJLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEvQmhDb0IscUJBQUdDLENBQUMsR0FBR2hCLEVBQUUsQ0FDTmlCLEtBREksR0FFSkMsR0FGSSxDQUVBckIsT0FGQSxFQUVTLElBRlQsRUFFZUwsY0FGZixFQUdKMEIsR0FISSxDQUdBaEIsT0FBTyxDQUFDQyxLQUhSLEVBSUpnQixHQUpJOzs7QUFRUEosbUJBQUdLLENBQUMsR0FBR2hCLEdBQUcsQ0FDTGEsS0FERSxHQUVGRSxHQUZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
