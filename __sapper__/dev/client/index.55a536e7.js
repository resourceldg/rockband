import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, j as append_dev, X as validate_store, Y as component_subscribe, K as createEventDispatcher, G as ClassBuilder, v as validate_slots, F as assign, H as exclude_internal_props, aq as writable, al as fade, ar as scale, ab as quadOut, aj as quadIn, C as Button, af as Spacer, a8 as utils, x as create_slot, k as space, c as claim_element, a as children, m as claim_space, b as detach_dev, f as add_location, g as attr_dev, ae as null_to_empty, h as insert_dev, M as listen_dev, B as update_slot, r as transition_in, T as group_outros, u as transition_out, U as check_outros, ac as add_render_callback, ao as create_in_transition, ap as create_out_transition, o as create_component, p as claim_component, q as mount_component, w as destroy_component, R as empty, a0 as binding_callbacks, t as text, l as claim_text, as as subscribe, J as get_spread_update, a5 as get_spread_object, n as noop, z as set_data_dev } from './client.3e061e1d.js';

/* src/components/Snackbar/Snackbar.svelte generated by Svelte v3.24.0 */
const file = "src/components/Snackbar/Snackbar.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-1ym8qvd-style";
  style.textContent = ".snackbar.svelte-1ym8qvd{min-width:344px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU25hY2tiYXIuc3ZlbHRlIiwic291cmNlcyI6WyJTbmFja2Jhci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG4gIGNvbnN0IHF1ZXVlID0gd3JpdGFibGUoW10pO1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGZhZGUsIHNjYWxlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gIGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciB9IGZyb20gXCJzdmVsdGVcIjtcblxuICBpbXBvcnQgeyBxdWFkT3V0LCBxdWFkSW4gfSBmcm9tIFwic3ZlbHRlL2Vhc2luZ1wiO1xuICBpbXBvcnQgQnV0dG9uIGZyb20gXCIuLi9CdXR0b25cIjtcbiAgaW1wb3J0IHsgU3BhY2VyIH0gZnJvbSBcIi4uL1V0aWxcIjtcbiAgaW1wb3J0IHV0aWxzLCB7IENsYXNzQnVpbGRlciB9IGZyb20gXCIuLi8uLi91dGlscy9jbGFzc2VzLmpzXCI7XG5cbiAgZXhwb3J0IGxldCB2YWx1ZSA9IGZhbHNlO1xuICBleHBvcnQgbGV0IHRpbWVvdXQgPSAyMDAwO1xuICBleHBvcnQgbGV0IGluUHJvcHMgPSB7IGR1cmF0aW9uOiAxMDAsIGVhc2luZzogcXVhZEluIH07XG4gIGV4cG9ydCBsZXQgb3V0UHJvcHMgPSB7IGR1cmF0aW9uOiAxMDAsIGVhc2luZzogcXVhZE91dCwgZGVsYXk6IDE1MCB9O1xuICBleHBvcnQgbGV0IGNvbG9yID0gXCJncmF5XCI7XG4gIGV4cG9ydCBsZXQgdGV4dCA9IFwid2hpdGVcIjtcbiAgZXhwb3J0IGxldCB0b3AgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBib3R0b20gPSB0cnVlO1xuICBleHBvcnQgbGV0IHJpZ2h0ID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgbGVmdCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IG5vQWN0aW9uID0gdHJ1ZTtcbiAgZXhwb3J0IGxldCBoYXNoID0gZmFsc2U7XG5cbiAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuICBjb25zdCBjbGFzc2VzRGVmYXVsdCA9IGBwb2ludGVyLWV2ZW50cy1hdXRvIGZsZXggYWJzb2x1dGUgcHktMiBweC00IHotMzAgbWItNCBjb250ZW50LWJldHdlZW4gbXgtYXV0b1xuICAgICAgcm91bmRlZCBpdGVtcy1jZW50ZXIgZWxldmF0aW9uLTIgaC0xMmA7XG4gIGNvbnN0IHdyYXBwZXJEZWZhdWx0ID0gXCJmaXhlZCB3LWZ1bGwgaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHBvaW50ZXItZXZlbnRzLW5vbmVcIjtcblxuICBleHBvcnQgbGV0IGNsYXNzZXMgPSB3cmFwcGVyRGVmYXVsdDtcblxuICBjb25zdCBjYiA9IG5ldyBDbGFzc0J1aWxkZXIoJCRwcm9wcy5jbGFzcywgY2xhc3Nlc0RlZmF1bHQpO1xuICBjb25zdCB3cmFwcGVyQ2IgPSBuZXcgQ2xhc3NCdWlsZGVyKGNsYXNzZXMsIHdyYXBwZXJEZWZhdWx0KTtcblxuICBsZXQgd0NsYXNzZXMgPSBpID0+IGk7XG4gIGxldCB0bTtcbiAgbGV0IG5vZGU7XG5cbiAgbGV0IGJnID0gKCkgPT4ge307XG5cbiAgJDoge1xuICAgIGNvbnN0IHUgPSB1dGlscyhjb2xvciB8fCBcImdyYXlcIik7XG4gICAgYmcgPSB1LmJnO1xuICB9XG5cbiAgJDoge1xuICAgIGhhc2ggPSBoYXNoIHx8ICh2YWx1ZSA/IGJ0b2EoYCR7dmFsdWV9JHtuZXcgRGF0ZSgpLnZhbHVlT2YoKX1gKSA6IG51bGwpO1xuICAgIHZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAkOiB0b2dnbGVyID0gKCkgPT4gdG9nZ2xlKHZhbHVlLCBoYXNoKTtcblxuICAkOiBpZiAodmFsdWUpIHtcbiAgICBxdWV1ZS51cGRhdGUodSA9PiBbLi4udSwgdG9nZ2xlcl0pO1xuICB9XG5cbiAgJDogaWYgKCFydW5uaW5nICYmIHZhbHVlICYmICRxdWV1ZS5sZW5ndGgpIHtcbiAgICAkcXVldWUuc2hpZnQoKSgpO1xuICB9XG5cbiAgJDogaWYgKCF2YWx1ZSkgY2xlYXJUaW1lb3V0KHRtKTtcblxuICBmdW5jdGlvbiB0b2dnbGUoaCwgaWQpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlICYmIHJ1bm5pbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhc2ggPSBydW5uaW5nID0gdmFsdWUgPSBpZDtcblxuICAgIGlmICghdGltZW91dCkgcmV0dXJuO1xuXG4gICAgdG0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhbHVlID0gcnVubmluZyA9IGhhc2ggPSBmYWxzZTtcbiAgICAgIGRpc3BhdGNoKFwiZmluaXNoXCIpO1xuXG4gICAgICBpZiAoJHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAkcXVldWUuc2hpZnQoKSgpO1xuICAgICAgfVxuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgJDogYyA9IGNiXG4gICAgICAuZmx1c2goKVxuICAgICAgLmFkZChiZyg4MDApLCBjb2xvcilcbiAgICAgIC5hZGQoXCJyaWdodC0wIG1yLTJcIiwgcmlnaHQpXG4gICAgICAuYWRkKFwidG9wLTAgbXQtMlwiLCB0b3ApXG4gICAgICAuYWRkKFwibGVmdC0wIG1sLTJcIiwgbGVmdClcbiAgICAgIC5hZGQoXCJib3R0b20tMFwiLCBib3R0b20pXG4gICAgICAuYWRkKFwic25hY2tiYXJcIiwgIW5vQWN0aW9uKVxuICAgICAgLmdldCgpO1xuXG4gIC8vIGZvciBzb21lIHJlYXNvbiBpdCBkb2Vzbid0IGdldCB1cGRhdGVkIG90aGVyd2lzZVxuICAkOiBpZiAobm9kZSkgbm9kZS5jbGFzc0xpc3QgPSBjO1xuXG4gIHdDbGFzc2VzID0gd3JhcHBlckNiXG4gICAgLmZsdXNoKClcbiAgICAuYWRkKGB0ZXh0LSR7dGV4dH1gKVxuICAgIC5nZXQoKTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5zbmFja2JhciB7XG4gICAgbWluLXdpZHRoOiAzNDRweDtcbiAgfVxuPC9zdHlsZT5cblxueyNpZiB2YWx1ZSAmJiAocnVubmluZyA9PT0gaGFzaCl9XG4gIDxkaXZcbiAgICBjbGFzcz1cImZpeGVkIHctZnVsbCBoLWZ1bGwgdG9wLTAgbGVmdC0wIHotMzAgcG9pbnRlci1ldmVudHMtbm9uZVwiXG4gID5cbiAgICA8ZGl2IGNsYXNzPXt3Q2xhc3Nlc30+XG4gICAgICA8ZGl2XG4gICAgICAgIGJpbmQ6dGhpcz17bm9kZX1cbiAgICAgICAgaW46c2NhbGU9e2luUHJvcHN9XG4gICAgICAgIG91dDpmYWRlPXtvdXRQcm9wc31cbiAgICAgICAgb246Y2xpY2s9eygpID0+IHZhbHVlID0gZmFsc2V9PlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgICB7I2lmICFub0FjdGlvbn1cbiAgICAgICAgICA8U3BhY2VyIC8+XG4gICAgICAgICAgPHNsb3QgbmFtZT1cImFjdGlvblwiPlxuICAgICAgICAgICAgeyNpZiAhdGltZW91dH1cbiAgICAgICAgICAgICAgPEJ1dHRvbiB0ZXh0IG9uOmNsaWNrPXsoKSA9PiB2YWx1ZSA9IGZhbHNlfT5DbG9zZTwvQnV0dG9uPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICA8L3Nsb3Q+XG4gICAgICAgIHsvaWZ9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG57L2lmfVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTBHRSxTQUFTLGVBQUMsQ0FBQyxBQUNULFNBQVMsQ0FBRSxLQUFLLEFBQ2xCLENBQUMifQ== */";
  append_dev(document.head, style);
}

const get_action_slot_changes = dirty => ({});

const get_action_slot_context = ctx => ({}); // (112:0) {#if value && (running === hash)}


function create_if_block(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  let div0_intro;
  let div0_outro;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template =
  /*$$slots*/
  ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[19], null);
  let if_block = !
  /*noAction*/
  ctx[5] && create_if_block_1(ctx);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      t = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true
      });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      t = claim_space(div0_nodes);
      if (if_block) if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file, 116, 6, 2707);
      attr_dev(div1, "class", div1_class_value = "" + (null_to_empty(
      /*wClasses*/
      ctx[6]) + " svelte-1ym8qvd"));
      add_location(div1, file, 115, 4, 2678);
      attr_dev(div2, "class", "fixed w-full h-full top-0 left-0 z-30 pointer-events-none");
      add_location(div2, file, 112, 2, 2595);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);

      if (default_slot) {
        default_slot.m(div0, null);
      }

      append_dev(div0, t);
      if (if_block) if_block.m(div0, null);
      /*div0_binding*/

      ctx[17](div0);
      current = true;

      if (!mounted) {
        dispose = listen_dev(div0, "click",
        /*click_handler_1*/
        ctx[18], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if (default_slot) {
        if (default_slot.p && dirty &
        /*$$scope*/
        524288) {
          update_slot(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[19], dirty, null, null);
        }
      }

      if (!
      /*noAction*/
      ctx[5]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*noAction*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }

      if (!current || dirty &
      /*wClasses*/
      64 && div1_class_value !== (div1_class_value = "" + (null_to_empty(
      /*wClasses*/
      ctx[6]) + " svelte-1ym8qvd"))) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      transition_in(if_block);
      add_render_callback(() => {
        if (div0_outro) div0_outro.end(1);
        if (!div0_intro) div0_intro = create_in_transition(div0, scale,
        /*inProps*/
        ctx[3]);
        div0_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      if (div0_intro) div0_intro.invalidate();
      div0_outro = create_out_transition(div0, fade,
      /*outProps*/
      ctx[4]);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div2);
      if (default_slot) default_slot.d(detaching);
      if (if_block) if_block.d();
      /*div0_binding*/

      ctx[17](null);
      if (detaching && div0_outro) div0_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(112:0) {#if value && (running === hash)}",
    ctx
  });
  return block;
} // (123:8) {#if !noAction}


function create_if_block_1(ctx) {
  let spacer;
  let t;
  let current;
  spacer = new Spacer({
    $$inline: true
  });
  const action_slot_template =
  /*$$slots*/
  ctx[15].action;
  const action_slot = create_slot(action_slot_template, ctx,
  /*$$scope*/
  ctx[19], get_action_slot_context);
  const action_slot_or_fallback = action_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      create_component(spacer.$$.fragment);
      t = space();
      if (action_slot_or_fallback) action_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      claim_component(spacer.$$.fragment, nodes);
      t = claim_space(nodes);
      if (action_slot_or_fallback) action_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(spacer, target, anchor);
      insert_dev(target, t, anchor);

      if (action_slot_or_fallback) {
        action_slot_or_fallback.m(target, anchor);
      }

      current = true;
    },
    p: function update(ctx, dirty) {
      if (action_slot) {
        if (action_slot.p && dirty &
        /*$$scope*/
        524288) {
          update_slot(action_slot, action_slot_template, ctx,
          /*$$scope*/
          ctx[19], dirty, get_action_slot_changes, get_action_slot_context);
        }
      } else {
        if (action_slot_or_fallback && action_slot_or_fallback.p && dirty &
        /*value, timeout*/
        5) {
          action_slot_or_fallback.p(ctx, dirty);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(spacer.$$.fragment, local);
      transition_in(action_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(spacer.$$.fragment, local);
      transition_out(action_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(spacer, detaching);
      if (detaching) detach_dev(t);
      if (action_slot_or_fallback) action_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(123:8) {#if !noAction}",
    ctx
  });
  return block;
} // (126:12) {#if !timeout}


function create_if_block_2(ctx) {
  let button;
  let current;
  button = new Button({
    props: {
      text: true,
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  button.$on("click",
  /*click_handler*/
  ctx[16]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const button_changes = {};

      if (dirty &
      /*$$scope*/
      524288) {
        button_changes.$$scope = {
          dirty,
          ctx
        };
      }

      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(126:12) {#if !timeout}",
    ctx
  });
  return block;
} // (127:14) <Button text on:click={() => value = false}>


function create_default_slot(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Close");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Close");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(127:14) <Button text on:click={() => value = false}>",
    ctx
  });
  return block;
} // (125:30)              


function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !
  /*timeout*/
  ctx[2] && create_if_block_2(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (!
      /*timeout*/
      ctx[2]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*timeout*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(125:30)              ",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block =
  /*value*/
  ctx[0] && running ===
  /*hash*/
  ctx[1] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, [dirty]) {
      if (
      /*value*/
      ctx[0] && running ===
      /*hash*/
      ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*value, running, hash*/
          3) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

const queue = writable([]);
let running = false;
const wrapperDefault = "fixed w-full h-full flex items-center justify-center pointer-events-none";

function instance($$self, $$props, $$invalidate) {
  let $queue;
  validate_store(queue, "queue");
  component_subscribe($$self, queue, $$value => $$invalidate(23, $queue = $$value));
  let {
    value = false
  } = $$props;
  let {
    timeout = 2000
  } = $$props;
  let {
    inProps = {
      duration: 100,
      easing: quadIn
    }
  } = $$props;
  let {
    outProps = {
      duration: 100,
      easing: quadOut,
      delay: 150
    }
  } = $$props;
  let {
    color = "gray"
  } = $$props;
  let {
    text = "white"
  } = $$props;
  let {
    top = false
  } = $$props;
  let {
    bottom = true
  } = $$props;
  let {
    right = false
  } = $$props;
  let {
    left = false
  } = $$props;
  let {
    noAction = true
  } = $$props;
  let {
    hash = false
  } = $$props;
  const dispatch = createEventDispatcher();
  const classesDefault = `pointer-events-auto flex absolute py-2 px-4 z-30 mb-4 content-between mx-auto
      rounded items-center elevation-2 h-12`;
  let {
    classes = wrapperDefault
  } = $$props;
  const cb = new ClassBuilder($$props.class, classesDefault);
  const wrapperCb = new ClassBuilder(classes, wrapperDefault);

  let wClasses = i => i;

  let tm;
  let node;

  let bg = () => {};

  function toggle(h, id) {
    if (value === false && running === false) {
      return;
    }

    $$invalidate(1, hash = running = $$invalidate(0, value = id));
    if (!timeout) return;
    $$invalidate(20, tm = setTimeout(() => {
      $$invalidate(0, value = running = $$invalidate(1, hash = false));
      dispatch("finish");

      if ($queue.length) {
        $queue.shift()();
      }
    }, timeout));
  }

  wClasses = wrapperCb.flush().add(`text-${text}`).get();
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Snackbar", $$slots, ['default', 'action']);

  const click_handler = () => $$invalidate(0, value = false);

  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      ((((((($$invalidate(7, node), $$invalidate(24, c)), $$invalidate(21, bg)), $$invalidate(8, color)), $$invalidate(12, right)), $$invalidate(10, top)), $$invalidate(13, left)), $$invalidate(11, bottom)), $$invalidate(5, noAction);
    });
  }

  const click_handler_1 = () => $$invalidate(0, value = false);

  $$self.$set = $$new_props => {
    $$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    if ("timeout" in $$new_props) $$invalidate(2, timeout = $$new_props.timeout);
    if ("inProps" in $$new_props) $$invalidate(3, inProps = $$new_props.inProps);
    if ("outProps" in $$new_props) $$invalidate(4, outProps = $$new_props.outProps);
    if ("color" in $$new_props) $$invalidate(8, color = $$new_props.color);
    if ("text" in $$new_props) $$invalidate(9, text = $$new_props.text);
    if ("top" in $$new_props) $$invalidate(10, top = $$new_props.top);
    if ("bottom" in $$new_props) $$invalidate(11, bottom = $$new_props.bottom);
    if ("right" in $$new_props) $$invalidate(12, right = $$new_props.right);
    if ("left" in $$new_props) $$invalidate(13, left = $$new_props.left);
    if ("noAction" in $$new_props) $$invalidate(5, noAction = $$new_props.noAction);
    if ("hash" in $$new_props) $$invalidate(1, hash = $$new_props.hash);
    if ("classes" in $$new_props) $$invalidate(14, classes = $$new_props.classes);
    if ("$$scope" in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
  };

  $$self.$capture_state = () => ({
    writable,
    queue,
    running,
    fade,
    scale,
    createEventDispatcher,
    quadOut,
    quadIn,
    Button,
    Spacer,
    utils,
    ClassBuilder,
    value,
    timeout,
    inProps,
    outProps,
    color,
    text,
    top,
    bottom,
    right,
    left,
    noAction,
    hash,
    dispatch,
    classesDefault,
    wrapperDefault,
    classes,
    cb,
    wrapperCb,
    wClasses,
    tm,
    node,
    bg,
    toggle,
    toggler,
    $queue,
    c
  });

  $$self.$inject_state = $$new_props => {
    $$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    if ("timeout" in $$props) $$invalidate(2, timeout = $$new_props.timeout);
    if ("inProps" in $$props) $$invalidate(3, inProps = $$new_props.inProps);
    if ("outProps" in $$props) $$invalidate(4, outProps = $$new_props.outProps);
    if ("color" in $$props) $$invalidate(8, color = $$new_props.color);
    if ("text" in $$props) $$invalidate(9, text = $$new_props.text);
    if ("top" in $$props) $$invalidate(10, top = $$new_props.top);
    if ("bottom" in $$props) $$invalidate(11, bottom = $$new_props.bottom);
    if ("right" in $$props) $$invalidate(12, right = $$new_props.right);
    if ("left" in $$props) $$invalidate(13, left = $$new_props.left);
    if ("noAction" in $$props) $$invalidate(5, noAction = $$new_props.noAction);
    if ("hash" in $$props) $$invalidate(1, hash = $$new_props.hash);
    if ("classes" in $$props) $$invalidate(14, classes = $$new_props.classes);
    if ("wClasses" in $$props) $$invalidate(6, wClasses = $$new_props.wClasses);
    if ("tm" in $$props) $$invalidate(20, tm = $$new_props.tm);
    if ("node" in $$props) $$invalidate(7, node = $$new_props.node);
    if ("bg" in $$props) $$invalidate(21, bg = $$new_props.bg);
    if ("toggler" in $$props) $$invalidate(22, toggler = $$new_props.toggler);
    if ("c" in $$props) $$invalidate(24, c = $$new_props.c);
  };

  let toggler;
  let c;

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*color*/
    256) {
       {
        const u = utils(color || "gray");
        $$invalidate(21, bg = u.bg);
      }
    }

    if ($$self.$$.dirty &
    /*hash, value*/
    3) {
       {
        $$invalidate(1, hash = hash || (value ? btoa(`${value}${new Date().valueOf()}`) : null));
        $$invalidate(0, value), $$invalidate(1, hash);
      }
    }

    if ($$self.$$.dirty &
    /*value, hash*/
    3) {
       $$invalidate(22, toggler = () => toggle(value, hash));
    }

    if ($$self.$$.dirty &
    /*value, toggler*/
    4194305) {
       if (value) {
        queue.update(u => [...u, toggler]);
      }
    }

    if ($$self.$$.dirty &
    /*running, value, $queue*/
    8388609) {
       if (!running && value && $queue.length) {
        $queue.shift()();
      }
    }

    if ($$self.$$.dirty &
    /*value, tm*/
    1048577) {
       if (!value) clearTimeout(tm);
    }

    if ($$self.$$.dirty &
    /*bg, color, right, top, left, bottom, noAction*/
    2112800) {
       $$invalidate(24, c = cb.flush().add(bg(800), color).add("right-0 mr-2", right).add("top-0 mt-2", top).add("left-0 ml-2", left).add("bottom-0", bottom).add("snackbar", !noAction).get());
    }

    if ($$self.$$.dirty &
    /*node, c*/
    16777344) {
      // for some reason it doesn't get updated otherwise
       if (node) $$invalidate(7, node.classList = c, node);
    }
  };

  $$props = exclude_internal_props($$props);
  return [value, hash, timeout, inProps, outProps, noAction, wClasses, node, color, text, top, bottom, right, left, classes, $$slots, click_handler, div0_binding, click_handler_1, $$scope];
}

class Snackbar extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-1ym8qvd-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      value: 0,
      timeout: 2,
      inProps: 3,
      outProps: 4,
      color: 8,
      text: 9,
      top: 10,
      bottom: 11,
      right: 12,
      left: 13,
      noAction: 5,
      hash: 1,
      classes: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Snackbar",
      options,
      id: create_fragment.name
    });
  }

  get value() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set value(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get timeout() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set timeout(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get inProps() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set inProps(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get outProps() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set outProps(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get color() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set color(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get text() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set text(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get top() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set top(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get bottom() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set bottom(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get right() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set right(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get left() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set left(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get noAction() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set noAction(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get hash() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set hash(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get classes() {
    throw new Error("<Snackbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set classes(value) {
    throw new Error("<Snackbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

function withColor(color, store) {
  return message => store.update(u => [...u, {
    message,
    ts: new Date(),
    color,

    toString() {
      return message;
    }

  }]);
}

function notificationQueue() {
  const store = writable([]);
  return {
    subscribe: store.subscribe,
    notify: withColor("gray", store),
    error: withColor("error", store),
    alert: withColor("alert", store),
    remove: i => store.update(u => {
      u.splice(i, 1);
      return u;
    })
  };
}

/* src/components/Snackbar/Notifications.svelte generated by Svelte v3.24.0 */

function create_default_slot$1(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
      /*message*/
      ctx[1]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes,
      /*message*/
      ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty &
      /*message*/
      2) set_data_dev(t,
      /*message*/
      ctx[1]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$1.name,
    type: "slot",
    source: "(32:0) <Snackbar   value={ts}   hash={ts}   {color}   {...item}   on:finish={() => {     queue.remove($queue.indexOf(item));     item = false;   }} >",
    ctx
  });
  return block;
}

function create_fragment$1(ctx) {
  let snackbar;
  let current;
  const snackbar_spread_levels = [{
    value:
    /*ts*/
    ctx[4]
  }, {
    hash:
    /*ts*/
    ctx[4]
  }, {
    color:
    /*color*/
    ctx[2]
  },
  /*item*/
  ctx[3]];
  let snackbar_props = {
    $$slots: {
      default: [create_default_slot$1]
    },
    $$scope: {
      ctx
    }
  };

  for (let i = 0; i < snackbar_spread_levels.length; i += 1) {
    snackbar_props = assign(snackbar_props, snackbar_spread_levels[i]);
  }

  snackbar = new Snackbar({
    props: snackbar_props,
    $$inline: true
  });
  snackbar.$on("finish",
  /*finish_handler*/
  ctx[6]);
  const block = {
    c: function create() {
      create_component(snackbar.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(snackbar.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(snackbar, target, anchor);
      current = true;
    },
    p: function update(ctx, [dirty]) {
      const snackbar_changes = dirty &
      /*ts, color, item*/
      28 ? get_spread_update(snackbar_spread_levels, [dirty &
      /*ts*/
      16 && {
        value:
        /*ts*/
        ctx[4]
      }, dirty &
      /*ts*/
      16 && {
        hash:
        /*ts*/
        ctx[4]
      }, dirty &
      /*color*/
      4 && {
        color:
        /*color*/
        ctx[2]
      }, dirty &
      /*item*/
      8 && get_spread_object(
      /*item*/
      ctx[3])]) : {};

      if (dirty &
      /*$$scope, message*/
      130) {
        snackbar_changes.$$scope = {
          dirty,
          ctx
        };
      }

      snackbar.$set(snackbar_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(snackbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(snackbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(snackbar, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

const notifier = notificationQueue();

function instance$1($$self, $$props, $$invalidate) {
  let $queue,
      $$unsubscribe_queue = noop,
      $$subscribe_queue = () => ($$unsubscribe_queue(), $$unsubscribe_queue = subscribe(queue, $$value => $$invalidate(5, $queue = $$value)), queue);

  $$self.$$.on_destroy.push(() => $$unsubscribe_queue());
  let {
    queue = notifier
  } = $$props;
  validate_store(queue, "queue");
  $$subscribe_queue();
  let message;
  let color = "gray";
  let item;
  let ts;
  const writable_props = ["queue"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Notifications> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;
  validate_slots("Notifications", $$slots, []);

  const finish_handler = () => {
    queue.remove($queue.indexOf(item));
    $$invalidate(3, item = false);
  };

  $$self.$set = $$props => {
    if ("queue" in $$props) $$subscribe_queue($$invalidate(0, queue = $$props.queue));
  };

  $$self.$capture_state = () => ({
    notificationQueue,
    notifier,
    Snackbar,
    queue,
    message,
    color,
    item,
    ts,
    $queue
  });

  $$self.$inject_state = $$props => {
    if ("queue" in $$props) $$subscribe_queue($$invalidate(0, queue = $$props.queue));
    if ("message" in $$props) $$invalidate(1, message = $$props.message);
    if ("color" in $$props) $$invalidate(2, color = $$props.color);
    if ("item" in $$props) $$invalidate(3, item = $$props.item);
    if ("ts" in $$props) $$invalidate(4, ts = $$props.ts);
  };

  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*item, $queue*/
    40) {
       {
        if (!item) {
          $$invalidate(3, item = $queue[0]);
        }

        if (typeof item === "string") {
          $$invalidate(1, message = item);
        } else if (item) {
          $$invalidate(1, message = item.toString());
          $$invalidate(2, color = item.color);
          $$invalidate(4, ts = item.ts);
        }
      }
    }
  };

  return [queue, message, color, item, ts, $queue, finish_handler];
}

class Notifications extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
      queue: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notifications",
      options,
      id: create_fragment$1.name
    });
  }

  get queue() {
    throw new Error("<Notifications>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set queue(value) {
    throw new Error("<Notifications>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export { Notifications as N, Snackbar as S, notifier as n };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNTVhNTM2ZTcuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1NuYWNrYmFyL1NuYWNrYmFyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9ub3RpZmljYXRpb24tcXVldWUuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9TbmFja2Jhci9Ob3RpZmljYXRpb25zLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbiAgY29uc3QgcXVldWUgPSB3cml0YWJsZShbXSk7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgZmFkZSwgc2NhbGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgaW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyIH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG4gIGltcG9ydCB7IHF1YWRPdXQsIHF1YWRJbiB9IGZyb20gXCJzdmVsdGUvZWFzaW5nXCI7XG4gIGltcG9ydCBCdXR0b24gZnJvbSBcIi4uL0J1dHRvblwiO1xuICBpbXBvcnQgeyBTcGFjZXIgfSBmcm9tIFwiLi4vVXRpbFwiO1xuICBpbXBvcnQgdXRpbHMsIHsgQ2xhc3NCdWlsZGVyIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2NsYXNzZXMuanNcIjtcblxuICBleHBvcnQgbGV0IHZhbHVlID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgdGltZW91dCA9IDIwMDA7XG4gIGV4cG9ydCBsZXQgaW5Qcm9wcyA9IHsgZHVyYXRpb246IDEwMCwgZWFzaW5nOiBxdWFkSW4gfTtcbiAgZXhwb3J0IGxldCBvdXRQcm9wcyA9IHsgZHVyYXRpb246IDEwMCwgZWFzaW5nOiBxdWFkT3V0LCBkZWxheTogMTUwIH07XG4gIGV4cG9ydCBsZXQgY29sb3IgPSBcImdyYXlcIjtcbiAgZXhwb3J0IGxldCB0ZXh0ID0gXCJ3aGl0ZVwiO1xuICBleHBvcnQgbGV0IHRvcCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGJvdHRvbSA9IHRydWU7XG4gIGV4cG9ydCBsZXQgcmlnaHQgPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBsZWZ0ID0gZmFsc2U7XG4gIGV4cG9ydCBsZXQgbm9BY3Rpb24gPSB0cnVlO1xuICBleHBvcnQgbGV0IGhhc2ggPSBmYWxzZTtcblxuICBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gIGNvbnN0IGNsYXNzZXNEZWZhdWx0ID0gYHBvaW50ZXItZXZlbnRzLWF1dG8gZmxleCBhYnNvbHV0ZSBweS0yIHB4LTQgei0zMCBtYi00IGNvbnRlbnQtYmV0d2VlbiBteC1hdXRvXG4gICAgICByb3VuZGVkIGl0ZW1zLWNlbnRlciBlbGV2YXRpb24tMiBoLTEyYDtcbiAgY29uc3Qgd3JhcHBlckRlZmF1bHQgPSBcImZpeGVkIHctZnVsbCBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcG9pbnRlci1ldmVudHMtbm9uZVwiO1xuXG4gIGV4cG9ydCBsZXQgY2xhc3NlcyA9IHdyYXBwZXJEZWZhdWx0O1xuXG4gIGNvbnN0IGNiID0gbmV3IENsYXNzQnVpbGRlcigkJHByb3BzLmNsYXNzLCBjbGFzc2VzRGVmYXVsdCk7XG4gIGNvbnN0IHdyYXBwZXJDYiA9IG5ldyBDbGFzc0J1aWxkZXIoY2xhc3Nlcywgd3JhcHBlckRlZmF1bHQpO1xuXG4gIGxldCB3Q2xhc3NlcyA9IGkgPT4gaTtcbiAgbGV0IHRtO1xuICBsZXQgbm9kZTtcblxuICBsZXQgYmcgPSAoKSA9PiB7fTtcblxuICAkOiB7XG4gICAgY29uc3QgdSA9IHV0aWxzKGNvbG9yIHx8IFwiZ3JheVwiKTtcbiAgICBiZyA9IHUuYmc7XG4gIH1cblxuICAkOiB7XG4gICAgaGFzaCA9IGhhc2ggfHwgKHZhbHVlID8gYnRvYShgJHt2YWx1ZX0ke25ldyBEYXRlKCkudmFsdWVPZigpfWApIDogbnVsbCk7XG4gICAgdmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gICQ6IHRvZ2dsZXIgPSAoKSA9PiB0b2dnbGUodmFsdWUsIGhhc2gpO1xuXG4gICQ6IGlmICh2YWx1ZSkge1xuICAgIHF1ZXVlLnVwZGF0ZSh1ID0+IFsuLi51LCB0b2dnbGVyXSk7XG4gIH1cblxuICAkOiBpZiAoIXJ1bm5pbmcgJiYgdmFsdWUgJiYgJHF1ZXVlLmxlbmd0aCkge1xuICAgICRxdWV1ZS5zaGlmdCgpKCk7XG4gIH1cblxuICAkOiBpZiAoIXZhbHVlKSBjbGVhclRpbWVvdXQodG0pO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZShoLCBpZCkge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiYgcnVubmluZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFzaCA9IHJ1bm5pbmcgPSB2YWx1ZSA9IGlkO1xuXG4gICAgaWYgKCF0aW1lb3V0KSByZXR1cm47XG5cbiAgICB0bSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFsdWUgPSBydW5uaW5nID0gaGFzaCA9IGZhbHNlO1xuICAgICAgZGlzcGF0Y2goXCJmaW5pc2hcIik7XG5cbiAgICAgIGlmICgkcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICRxdWV1ZS5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAkOiBjID0gY2JcbiAgICAgIC5mbHVzaCgpXG4gICAgICAuYWRkKGJnKDgwMCksIGNvbG9yKVxuICAgICAgLmFkZChcInJpZ2h0LTAgbXItMlwiLCByaWdodClcbiAgICAgIC5hZGQoXCJ0b3AtMCBtdC0yXCIsIHRvcClcbiAgICAgIC5hZGQoXCJsZWZ0LTAgbWwtMlwiLCBsZWZ0KVxuICAgICAgLmFkZChcImJvdHRvbS0wXCIsIGJvdHRvbSlcbiAgICAgIC5hZGQoXCJzbmFja2JhclwiLCAhbm9BY3Rpb24pXG4gICAgICAuZ2V0KCk7XG5cbiAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGRvZXNuJ3QgZ2V0IHVwZGF0ZWQgb3RoZXJ3aXNlXG4gICQ6IGlmIChub2RlKSBub2RlLmNsYXNzTGlzdCA9IGM7XG5cbiAgd0NsYXNzZXMgPSB3cmFwcGVyQ2JcbiAgICAuZmx1c2goKVxuICAgIC5hZGQoYHRleHQtJHt0ZXh0fWApXG4gICAgLmdldCgpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnNuYWNrYmFyIHtcbiAgICBtaW4td2lkdGg6IDM0NHB4O1xuICB9XG48L3N0eWxlPlxuXG57I2lmIHZhbHVlICYmIChydW5uaW5nID09PSBoYXNoKX1cbiAgPGRpdlxuICAgIGNsYXNzPVwiZml4ZWQgdy1mdWxsIGgtZnVsbCB0b3AtMCBsZWZ0LTAgei0zMCBwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgPlxuICAgIDxkaXYgY2xhc3M9e3dDbGFzc2VzfT5cbiAgICAgIDxkaXZcbiAgICAgICAgYmluZDp0aGlzPXtub2RlfVxuICAgICAgICBpbjpzY2FsZT17aW5Qcm9wc31cbiAgICAgICAgb3V0OmZhZGU9e291dFByb3BzfVxuICAgICAgICBvbjpjbGljaz17KCkgPT4gdmFsdWUgPSBmYWxzZX0+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICAgIHsjaWYgIW5vQWN0aW9ufVxuICAgICAgICAgIDxTcGFjZXIgLz5cbiAgICAgICAgICA8c2xvdCBuYW1lPVwiYWN0aW9uXCI+XG4gICAgICAgICAgICB7I2lmICF0aW1lb3V0fVxuICAgICAgICAgICAgICA8QnV0dG9uIHRleHQgb246Y2xpY2s9eygpID0+IHZhbHVlID0gZmFsc2V9PkNsb3NlPC9CdXR0b24+XG4gICAgICAgICAgICB7L2lmfVxuICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgey9pZn1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbnsvaWZ9XG4iLCJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuZnVuY3Rpb24gd2l0aENvbG9yKGNvbG9yLCBzdG9yZSkge1xuICByZXR1cm4gbWVzc2FnZSA9PlxuICAgIHN0b3JlLnVwZGF0ZSh1ID0+IFtcbiAgICAgIC4uLnUsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHRzOiBuZXcgRGF0ZSgpLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm90aWZpY2F0aW9uUXVldWUoKSB7XG4gIGNvbnN0IHN0b3JlID0gd3JpdGFibGUoW10pO1xuXG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUsXG5cbiAgICBub3RpZnk6IHdpdGhDb2xvcihcImdyYXlcIiwgc3RvcmUpLFxuICAgIGVycm9yOiB3aXRoQ29sb3IoXCJlcnJvclwiLCBzdG9yZSksXG4gICAgYWxlcnQ6IHdpdGhDb2xvcihcImFsZXJ0XCIsIHN0b3JlKSxcblxuICAgIHJlbW92ZTogaSA9PlxuICAgICAgc3RvcmUudXBkYXRlKHUgPT4ge1xuICAgICAgICB1LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHU7XG4gICAgICB9KVxuICB9O1xufVxuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGltcG9ydCBub3RpZmljYXRpb25RdWV1ZSBmcm9tIFwiLi4vLi4vbm90aWZpY2F0aW9uLXF1ZXVlXCI7XG5cbiAgZXhwb3J0IGNvbnN0IG5vdGlmaWVyID0gbm90aWZpY2F0aW9uUXVldWUoKTtcbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgU25hY2tiYXIgZnJvbSBcIi4vU25hY2tiYXIuc3ZlbHRlXCI7XG5cbiAgZXhwb3J0IGxldCBxdWV1ZSA9IG5vdGlmaWVyO1xuICBsZXQgbWVzc2FnZTtcbiAgbGV0IGNvbG9yID0gXCJncmF5XCI7XG4gIGxldCBpdGVtO1xuICBsZXQgdHM7XG5cbiAgJDoge1xuICAgIGlmICghaXRlbSkge1xuICAgICAgaXRlbSA9ICRxdWV1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1lc3NhZ2UgPSBpdGVtO1xuICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgIGNvbG9yID0gaXRlbS5jb2xvcjtcbiAgICAgIHRzID0gaXRlbS50cztcbiAgICB9XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxTbmFja2JhclxuICB2YWx1ZT17dHN9XG4gIGhhc2g9e3RzfVxuICB7Y29sb3J9XG4gIHsuLi5pdGVtfVxuICBvbjpmaW5pc2g9eygpID0+IHtcbiAgICBxdWV1ZS5yZW1vdmUoJHF1ZXVlLmluZGV4T2YoaXRlbSkpO1xuICAgIGl0ZW0gPSBmYWxzZTtcbiAgfX1cbj5cbiAge21lc3NhZ2V9XG48L1NuYWNrYmFyPiJdLCJuYW1lcyI6WyJjdHgiLCJydW5uaW5nIiwicXVldWUiLCJ3cml0YWJsZSIsIndyYXBwZXJEZWZhdWx0IiwidmFsdWUiLCJ0aW1lb3V0IiwiaW5Qcm9wcyIsImR1cmF0aW9uIiwiZWFzaW5nIiwicXVhZEluIiwib3V0UHJvcHMiLCJxdWFkT3V0IiwiZGVsYXkiLCJjb2xvciIsInRleHQiLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJub0FjdGlvbiIsImhhc2giLCJkaXNwYXRjaCIsImNyZWF0ZUV2ZW50RGlzcGF0Y2hlciIsImNsYXNzZXNEZWZhdWx0IiwiY2xhc3NlcyIsImNiIiwiQ2xhc3NCdWlsZGVyIiwiJCRwcm9wcyIsImNsYXNzIiwid3JhcHBlckNiIiwid0NsYXNzZXMiLCJpIiwidG0iLCJub2RlIiwiYmciLCJ0b2dnbGUiLCJoIiwiaWQiLCJzZXRUaW1lb3V0IiwiJHF1ZXVlIiwibGVuZ3RoIiwic2hpZnQiLCJmbHVzaCIsImFkZCIsImdldCIsIiQiLCJ1IiwidXRpbHMiLCJidG9hIiwiRGF0ZSIsInZhbHVlT2YiLCJ0b2dnbGVyIiwidXBkYXRlIiwiY2xlYXJUaW1lb3V0IiwiYyIsImNsYXNzTGlzdCIsIndpdGhDb2xvciIsInN0b3JlIiwibWVzc2FnZSIsInRzIiwidG9TdHJpbmciLCJub3RpZmljYXRpb25RdWV1ZSIsInN1YnNjcmliZSIsIm5vdGlmeSIsImVycm9yIiwiYWxlcnQiLCJyZW1vdmUiLCJzcGxpY2UiLCJub3RpZmllciIsIml0ZW0iLCJpbmRleE9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwSGNBLEVBQUFBLEdBQVEsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVBOQSxNQUFBQSxHQUFRLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT1ZBLE1BQUFBLEdBQVEsRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUE5BLE1BQUFBLEdBQVEsRUFBQTs7Ozs7Ozs7Ozs7O0FBR05BLFFBQUFBLEdBQU8sRUFBQTs7Ozs7Ozs7Ozs7QUFDUEEsTUFBQUEsR0FBUSxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTVJBLEVBQUFBLEdBQU8sRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQVBBLE1BQUFBLEdBQU8sRUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWRwQkEsRUFBQUEsR0FBSyxFQUFBLENBQUwsSUFBVUMsT0FBTzs7QUFBS0QsRUFBQUEsR0FBSSxFQUFBLENBQTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQUEsTUFBQUEsR0FBSyxF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
